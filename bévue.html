<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bévue</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #ffffff;
      touch-action: none;
      font-family: Arial, Helvetica, sans-serif;
    }
    canvas { display: block; }
    #loading {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 14px;
      color: #666;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="loading">Chargement des images...</div>
  <canvas id="scene"></canvas>

  <script>
    const canvas = document.getElementById('scene');
    const ctx = canvas.getContext('2d');
    const loadingDiv = document.getElementById('loading');

    let width = 0, height = 0;
    let baseFontSize = 200;

    const word = ['b', 'é', 'v', 'u', 'e'];
    const letters = word.map((char, i) => ({
      char,
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      vx: 0,
      vy: 0,
      targetX: 0,
      targetY: 0
    }));

    function resize() {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      baseFontSize = Math.min(width, height) * 0.35;
      letters.forEach((l, i) => {
        l.targetX = width / 2 + (i - 2) * baseFontSize * 0.45;
        l.targetY = height / 2;
      });
    }
    window.addEventListener('resize', resize);

    const pointer = { x: 0, y: 0, active: false };

    function setPointer(x, y) {
      pointer.x = x;
      pointer.y = y;
      pointer.active = true;
    }

    // -------- Chargement progressif des images --------
    const MAX_IMAGES = 207;
    const PRELOAD_COUNT = 20; // Charger seulement 20 images au démarrage
    const loadedImages = [];
    const imageCache = new Map();
    let loadedCount = 0;
    let totalToLoad = PRELOAD_COUNT;

    function loadImage(index) {
      return new Promise((resolve) => {
        const src = `images/img${index}.jpg`;
        const img = new Image();
        
        img.onload = () => {
          loadedImages.push(img);
          imageCache.set(index, img);
          loadedCount++;
          loadingDiv.textContent = `Images chargées: ${loadedCount}/${totalToLoad}`;
          if (loadedCount >= totalToLoad) {
            loadingDiv.style.display = 'none';
          }
          resolve(true);
        };
        
        img.onerror = () => {
          console.warn(`Impossible de charger: ${src}`);
          loadedCount++;
          resolve(false);
        };
        
        img.src = src;
      });
    }

    // Charger les premières images
    async function preloadImages() {
      const promises = [];
      for (let i = 1; i <= Math.min(PRELOAD_COUNT, MAX_IMAGES); i++) {
        promises.push(loadImage(i));
      }
      await Promise.all(promises);
      
      // Charger les images restantes en arrière-plan
      loadRemainingImages();
    }

    async function loadRemainingImages() {
      for (let i = PRELOAD_COUNT + 1; i <= MAX_IMAGES; i++) {
        await loadImage(i);
        // Petite pause pour ne pas surcharger le navigateur
        await new Promise(resolve => setTimeout(resolve, 50));
      }
    }

    const bgSprites = [];
    const BG_LIFETIME = 3000;
    const MAX_SPRITES = 50; // Limiter le nombre de sprites actifs
    let lastSpawn = 0;

    function spawnBG(x, y) {
      if (loadedImages.length === 0) return;
      const now = performance.now();
      if (now - lastSpawn < 80) return;
      lastSpawn = now;

      // Limiter le nombre de sprites pour éviter les problèmes de performance
      if (bgSprites.length >= MAX_SPRITES) {
        bgSprites.shift(); // Retirer le plus ancien
      }

      const img = loadedImages[Math.floor(Math.random() * loadedImages.length)];
      bgSprites.push({
        img,
        x,
        y,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        scale: 0.2 + Math.random() * 0.2,
        born: now
      });
    }

    // -------- Interactions --------
    window.addEventListener('mousemove', e => {
      setPointer(e.clientX, e.clientY);
      spawnBG(e.clientX, e.clientY);
    });

    window.addEventListener('mouseleave', () => pointer.active = false);

    window.addEventListener('touchstart', e => {
      const t = e.touches[0];
      setPointer(t.clientX, t.clientY);
      spawnBG(t.clientX, t.clientY);
    }, { passive: false });

    window.addEventListener('touchmove', e => {
      const t = e.touches[0];
      setPointer(t.clientX, t.clientY);
      spawnBG(t.clientX, t.clientY);
    }, { passive: false });

    window.addEventListener('touchend', () => pointer.active = false);

    // -------- Animation --------
    function update() {
      ctx.clearRect(0, 0, width, height);
      const now = performance.now();

      // Images de fond
      for (let i = bgSprites.length - 1; i >= 0; i--) {
        const s = bgSprites[i];
        const age = now - s.born;
        if (age > BG_LIFETIME) {
          bgSprites.splice(i, 1);
          continue;
        }
        s.x += s.vx;
        s.y += s.vy;
        const w = s.img.width * s.scale;
        const h = s.img.height * s.scale;
        ctx.drawImage(s.img, s.x - w / 2, s.y - h / 2, w, h);
      }

      // Lettres
      ctx.fillStyle = '#000';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `${baseFontSize}px Arial`;

      letters.forEach(l => {
        l.vx += (l.targetX - l.x) * 0.002;
        l.vy += (l.targetY - l.y) * 0.002;

        if (pointer.active) {
          const dx = l.x - pointer.x;
          const dy = l.y - pointer.y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = Math.min(150 / dist, 5);
          l.vx += (dx / dist) * force;
          l.vy += (dy / dist) * force;
        }

        l.vx *= 0.92;
        l.vy *= 0.92;
        l.x += l.vx;
        l.y += l.vy;
        ctx.fillText(l.char, l.x, l.y);
      });

      requestAnimationFrame(update);
    }

    resize();
    preloadImages().then(() => {
      update();
    });
  </script>
</body>
</html>